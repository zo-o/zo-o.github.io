---
title: 알고리즘기초3_2_다이나믹프로그래밍 문제풀이1
categories:
 - Algorithm
tags:
 - study
 - 다이나믹프로그래밍
---

<기초 3_2>  **다이나믹프로그래밍 문제풀이 1**

**1로 만들기**

## 문제

[https://www.acmicpc.net/problem/1463](https://www.acmicpc.net/problem/1463)

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

## 풀이

**다이나믹에 해당되는 지 판별**
1. Overlapping Subproblem : 겹치는 부분 문제
2. Optimal Substructure : 문제의 정답을 작은 문제들의 정답에서 구할 수 있을 때

**배열 D[N] 에 넣을 값 판별**
=> N을 1로 만드는데 필요한 연산의 최소값

**문제 나누기**
1. N이 3으로 나누어 떨어지면 3으로 나눈다.
-> *최소값은 D[N/3]+1*

2. N이 2로 나누어 떨어지면 2로 나눈다.
-> *최소값은 D[N/2]+1*

3. 1을 뺀다.
-> *최소값은 D[N-1]+1*

=> N을 1로 만드는데 필요한 연산의 최소값은 1~3 연산의 최소값이다.

**예외**
 n==1 일때는 구하지 않음

## 코드

*top down 방식*

```c
int go (int n){
  if(n==1) return 0; //예외
  if(d[n]>0) return d[n]; //이미 값을 구한 경우
  d[n]=go(n-1)+1; //1을 뺏을 경우
  if(n%2==0){ //2로 나누었을 경우
    int temp=go(n/2)+1;
    if(d[n]>temp) d[n]=temp;
  }
  if(n%3==0){ //3으로 나누었을 경우
    int temp=go(n/3)+1;
    if(d[n]>temp) d[n]=temp;
  }
  return d[n];
}
```

*bottom up 방식*

```c
d[1]=0;
for(int i=2;i<=n;i++){
  d[i]=d[i-1]+1; //1을 빼는 경우
  if(i%2==0 && d[i]>d[i/2]+1){
    d[i]=d[i/2]+1;
  }
  if(i%3==0 && d[i]>d[i/3]+1){
    d[i]=d[i/3]+1;
  }
}
```
