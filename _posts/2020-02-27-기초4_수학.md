---
title: 알고리즘기초4_수학
categories:
 - Algorithm
tags:
 - study
 - 수학
---


## 나머지 연산

**(A+B)%C = ((A%C)+(B%C))%C**
다이나믹에서 경우의 수를 구하는 문제일 때 주로 사용한다.(나머지를 출력해라)
값이 너무 커질경우 미리 나누어준다.

**(A-B)%C = ((A%C)-(B%C)+C)%C**
뺄셈의 경우 나머지 연산을 한 결과가 음수가 나올 수 있기 때문에 C를 더해준다.

## 최대공약수

두 수의 공통된 약수 중에서 가장 큰 정

최대공약수를 빠르게 구하는 법 :  **유클리드 호제법**

**GCD(a,b) = GCD(b,a%b)**
a%b 를 계속하다가 0이 되었을 때 나머지가 최대공약수이다.

## 최소공배수

최소공배수=최대공약수*(a/최대공약수)* (b/최대공약수)

최소공배수=(a*b)/최대공약수
*최소공배수가 자료형 범위를 넘어가지 않게 잘 확인하기*


## 소수

소수를 구하는 가장 빠른 방법은 루트 N까지 검사하는 것이다.
**루트n까지 검사하는 법**
*i * i<=n*

### 1부터 n까지의 범위에 있는 모든 소수를 구하는 법

**에라토스테네스의 체**

1. 2부터 n까지 모든 수를 써놓는다.
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
3. 그 수는 소수이다.
4. 그 수의 배수를 모두 지운다. (*배수를 지울 때는 * 2부터 할 필요가 없다. * n 부터 차례대로 지워준다. n*n 이 범위를 넘을경우 멈춘다.*)


```
int p[100];//소수저장
int pn;//소수의 개수
bool c[101];//원래 false 지워졌으면 true
int n=100;

for(int i=2;i<=n;i++){
  if(c[i]==false){ //지워지지않은 수
    p[pn++]=i; //소수
    for(int j=i*i;j<=n;j+=i){ //배수지우기
      c[j]=true;
    }
  }
}
```

i의 수가 클 경우 i*i 는 지양한다.


## 소인수분해

소인수 : 약수이자 소수
n을 소인수분해했을 때 나타날 수 있는 가장 큰 값은 루트n이다.
2부터 루트n까지 for문을 돌며 나눌 수 없을 때까지 계속 나눈다.

```
for(int i=2;i*i<=n ;i++){
  while(n%i==0){
    printf("%d\n",i);
    n/=i;
  }
}
if(n>1){
  printf("%d\n",n);
}
```


## 팩토리얼
