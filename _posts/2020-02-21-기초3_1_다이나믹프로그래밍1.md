---
title: 알고리즘기초3_1_다이나믹프로그래밍1
categories:
 - Algorithm
tags:
 - study
 - 다이나믹프로그래밍
---


<기초 3_1>  **다이나믹프로그래밍 1**

## 다이나믹프로그래밍

**큰 문제를 작은 문제로 나눠서 푸는 알고리즘**

다이나믹 프로그래밍 문제는 다음을 만족시켜야 한다.

1. Overlapping Subproblem : 겹치는 부분 문제 f=f0 + f1
2. Optimal Substructure : 문제의 정답을 작은 문제들의 정답에서 구할 수 있을 때

예) 피보나치 수
예) 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.

각 부분 문제는 답이 같기 때문에 한 번만 풀어서 **정답을 메모해놓는다.**
이런 메모하는 것을 코드에서는 **배열에 저장하는 방식** 으로 구현한다.

_ _ _



**다이나믹 문제를 푸는 방식**

- Top-down : 큰 문제를 작게
- Bottom-up : 작은 문제부터 차례대로

### Top-down

재귀호출 이용

1. 문제를 작은 문제로 나눈다.
2. 작은 문제를 푼다.
3. 문제를 푼다.

++시간복잡도++ : 채워야하는 배열 칸의 개수 * 한 칸을 채울때의 시간복잡도


### Bottom-up

for 문 이용

1. 문제를 작은 문제부터 빠짐없이 차례대로 푼다.
2. 문제의 크기를 조금씩 크게 만들면서 푼다.
3. 문제를 푼다.


_ _ _


### 피보나치 수 구하기

피보나치 수를 구하는 함수를 만든다.
예외 ) F0=0, F1=1

n번째 피보나치 수의 값을 배열에 저장한다.

다음 번째 피보나치 수를 구할 때 배열에 저장한 값을 꺼내서 구한다.

*(top-down방식)*

```c++
int memo[100];//구한 피보나치 수들을 저장
int fibonacci (int n){
  if(n<=1){
    return n;
  }else{
    //이미 구한 값일 경우
    if(memo[n]>0){
      return memo[n];
    }
    memo[n]=fibonacci(n-1)+fibonacci(n-2);
    return memo[n];
  }
}
```

시간복잡도: N * 1 = O(N)  


*(bottom-up방식)*
```c++
int d[100];
int fibonacci(int n){
  d[0]=0;
  d[1]=1;
  for(int i=2 ; i<=n; i++){
    d[i]=d[i-1]+d[i-2];
  }
  return d[n]
}
```

_ _ _ 


### 문제 풀이 전략

1. d[i]에 어떤 것이 들어갈지 생각하기
2. d[i]를 어떻게 구할지 **ex) d[i]=d[i-1]+d[i-2]**