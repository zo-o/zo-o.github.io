---
title: 문자열 폭발
categories:
 - Algorithm
tags:
 - problem
 - c++
 - 문자열
---
## 문제

[https://www.acmicpc.net/problem/9935](https://www.acmicpc.net/problem/9935)
상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.

폭발은 다음과 같은 과정으로 진행된다.

- 문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.
- 새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.
- 폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.

상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 "FRULA"를 출력한다.

폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.

## 입력

첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.

둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.

두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, ..., 9로만 이루어져 있다.

## 풀이

#### 첫 번째 풀이(시간 초과)
폭발 문자열을 찾을 수 없을 때까지 find함수를 사용하여 문자열을 찾고 erase로 지움
```c++
#include <iostream>
#include <string>

using namespace std;



int main()
{
    string s;//주어진 문자열
    string x;//폭발 문자열

    cin>>s>>x;


    while(true){
        if(s.find(x)==string::npos){
            break;
        }else{
            s.erase(s.find(x),x.size());
        }
    }

    cout<<s;

    return 0;
}

```
=> 시간초과 발생
비교연산을 1억번 하는데 1초가 걸림
문자열의 최대 길이가 1,000,000이기 때문에 문자열을 찾고 지우고, 다시 찾는 식으로 하면 O(N^2)이므로 백만 * 백만해서 1억이 초과됨

=>O(N)이 되도록 **모든 폭발 문자열을 찾아가면서 동시에 지워야 함**

#### 두 번째 풀이

**모든 폭발 문자열을 찾아가면서 동시에 지워야 함**

1. 문자를 차례대로 추가해가면서 폭발문자열의 마지막 문자가 나올 경우 방금 지나친 문자들이 폭발문자열과 일치하는지 찾아본다.  
2. 일치할 경우 지운다.
3. 1~ 2를 반복한다.

한번의 검사로 문제를 해결할 수 있다. =>O(N)

```c++
#include <iostream>
#include <string>
#include<vector>
using namespace std;



int main()
{
    string s;//주어진 문자열
    string x;//폭발 문자열

    cin>>s>>x;
    string v="";
     int xsize=x.size();

   for(int i=0;i<s.size();i++){
       v+=s[i];
       if(s[i]==x[xsize-1] && v.size()>=xsize){//추가한 문자가 폭발 문자열의 마지막과 같으면 방금 지난게 폭발문자열인지 확인
          if(v.substr(v.size()-xsize)==x)
          {
              v.erase(v.size()-xsize,x.size());
          }
       }
   }
   if(v.size()==0) cout<<"FRULA";
    else cout<<v;

    return 0;
}
```

<오류 1> 폭발문자열이 있는지 확인하는 과정에서 find함수사용
find함수를 쓸 경우 문자열의 길이만큼 찾게 된다. 여기선 문자열의 마지막 부분만 확인하면 되므로 substr을 사용했다.

<오류 2> 런타임 에러
substr에 -인덱스를 넣어서 런타임 에러가 발생했다
조건문에 정답 문자열의 길이가 폭발문자열의 길이보다 클 경우에만 문자열을 비교하도록 넣어주었다.
