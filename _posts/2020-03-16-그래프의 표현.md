---
title: 그래프의 표현
categories:
 - Algorithm
tags:
 - study
 - 그래프
---

## 그래프

정점n과 간선m으로 이루어짐
주로 경로문제에 이용됨 ex)최단거리

단방향그래프와 양방향그래프가 있음.
가중치가 있을 수 있다.


### 그래프의 표현 방법들

#### 인접행렬

정점의 개수 n x n 크기의 이차원 배열을 만든다.
- i->j로 가는 간선이 있을 때 : a[i][j]=1
- i->j로 가는 간선이 없을 때 : a[i][j]=0

*인접행렬은 불필요한 공간이 많이 남으므로 주로 이용하지 않는다.*

- 가중치가 있을 경우 이차원배열에 해당하는 가중치를 저장한다. : a[i][j]=w
- 가중치가 정수범위에 해당하여 하나의 배열만으로 간선의 유무를 확인할 수 없을 경우 두개의 이차원 배열을 만든다.

- 공간복잡도 O(정점의 갯수^2)

#### 인접리스트

링크드 리스트 사용
a[i] :  i 와 연결된 정점을 링크드 리스트로 구현
간선이 여러개 인 경우에는 인접행렬보다 인접리스트가 좋다.
*주로 인접리스트 사용*

vector를 사용한다.

- 공간복잡도 : O(간선의 갯수*2)

**가중치가 없는 양방향 그래프**

vector<int>를 사용하여 각 정점의 배열a[i]에 정점i와 연결된 정점들의 리스트를 담는다.
```
#include <cstdio>
#include <vector>
using namespace std;
vector<int> a[10];  //2차원배열, vector<int> 가 10 개
int main(){
  int n,m;
  scanf("%d %d",&n,&m);
  for(int i=0;i<m;i++){
    int u,v;
    scanf("%d %d",&u,&v);
    a[u].push_back(v); //a[i]에는 i와 연결된 정점들의 리스트가 담기게 된다.
    a[v].push_back(u); //양방향 그래프인경우
  }
}
```


**가중치가 있는 양방향 그래프**

vector<pair<int,int>> 를 사용하여 각 정점의 배열 a[i]에 정점i와 연결된 정점과 해당하는 가중치를 쌍으로 담는다.

```
#include <cstdio>
#include <vector>
using namespace std;

vector<pair<int,int>> a[10];
int main(){
  int n,m; //정점의 갯수, 간선의 갯수
  scanf("%d %d",&n,&m);
  for(int i=0;i<m;i++){
    int u,v,w; //정점, 정점, 가중치
    scanf("%d %d %d",&u,&v,&w);
    a[u].push_back(make_pair(v,w));
    a[v].push_back(make_pair(u,w));

  }
}

```

#### 간선 리스트

stl 을 사용할 수 없는 경우

1. E[간선의 갯수*2] 배열에 간선을 모두 저장한다.
2. cnt[i] 배열에 각 간선의 앞 정점i을 기준으로 연결된 정점의 갯수를 센다.
3. cnt[i] 배열에서 각 자리까지의 누적합을 구한다
4. i번 정점과 연결된 간선은 E[cnt[i-1]] 부터 E[cnt[i]-1] 까지이다.


### 그래프의 탐색

목적 : **모든 정점을 1번씩 방문**

- DFS : 깊이 우선 탐색 -> 최대한 깊숙히 많이 *스택 사용*
- BFS : 너비 우선 탐색 -> 최대한 넓게 *큐 사용*

- BFS 는 모든 가중치가 1이라고 할 때 최단거리를 찾는 것과 같게 된다.


#### DFS

 스택을 이용해서 갈 수 있는 만큼 많이 가면서 정점을 지나칠때마다 어딜 지나쳤는지 스택에 저장한다. 더이상 갈 수 없으면 스택에 저장되어 있는 값을 이용해 바로 이전 정점으로 돌아간다.

 check[i] : 각 정점을 방문했는지 체크하는 배열 ( 0 과 1 )


1. 1번 정점으로부터 출발, 갈 수 있는 경로가 여러개일경우 값이 작은 정점을 먼저 간다.
2. i정점에 가면 스택에 i를 추가한다. 새로운 정점에 갈 경우 check[i]를 1로 변경한다.
3. 방문하지않은 정점으로 계속 간다.
4. 더이상 갈 수 없을 경우 pop()을 통해 이전 정점으로 가서 방문하지 않은 곳이 없는지 확인한다.
5. 스택이 빌 때 까지 pop()을 수행하며 방문하지 않은 곳이 없는지 확인한다..

*인접리스트와 재귀함수를 이용한 DFS*
```
vector<int> a[정점의갯수]; //각 정점과 연결된 정점들이 들어간 인접리스트
check[정점의갯수]; // 각 정점을 방문했는지 확인


void dfs(int x){ //x정점을 방문했다
  check[x]=true; //방문 체크
  for(int i=0;i<a[x].size();i++){
    int y=a[x][i];
    if(check[y]==false){
      dfs(y);
    }
  }

}
```

#### BFS
장점:
-  출발노드에서 목표노드까지의 최단 길이 경로를 보장한다.

단점:
- 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 한다.

- 해가 존재하지 않는다면 유한(finite) 그래프의 경우에는 모든 그래프를 탐색한 후에 실패로 끝난다.

- 무한(infinite) 그래프의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못한다.



큐를 이용하여 지금 위치에서 갈 수 있는 모든 정점을 큐에 넣는다.

*큐에 넣을 때* 방문했다고 *체크* 해야 한다.

check[i] : 각 정점을 방문했는지 체크하는 배열 ( 0 과 1 )

1. 첫번째 정점을 큐에 넣고 체크배열을 1로 바꾼다.
2. 첫번째 정점으로부터 갈 수 있는 모든 정점을 큐에 넣고 체크배열을 1로 바꾼다.
3. 큐를 pop()하고 첫번째 정점에서 갈 수 있는 정점중 체크표시가 0인 정점을 큐에 추가하고 체크배열을 1로 바꾼다.
4. 큐가 빌 때까지 반복한다.


*인접리스트와 큐를 이용한 BFS 구현*

```
queue<int> q;
check[1]=true; q.push(1); //첫번째 정점 추가
while(!q.empty()){
  int x=q.front(); q.pop();
  prinf("%d",x);
  for(int i=0;i<a[x].size();i++){
    int y=a[x][i];
    if(check[y]==false){
      check[y]=true; q.push(y);
    }
  }
}

```
`memset(check,false,sizeof(check));` : check 배열을 false로 초기화 *#include <cstring> 필요*
